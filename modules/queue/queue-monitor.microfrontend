class QueueMonitor extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    const bootstrapCdn =
      'https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css';
    this.shadowRoot.innerHTML = `
<link rel="stylesheet" href="${bootstrapCdn}">
<style>
  :host {
    display: block;
  }
</style>
<div class="card shadow-sm">
  <div class="card-body">
    <div class="d-flex justify-content-between align-items-start flex-wrap gap-3">
      <div>
        <h2 class="h5 mb-1">Queue Monitor</h2>
        <p class="text-muted mb-0">Mensajes procesados</p>
      </div>
      <div id="count" class="display-6 fs-2 fw-semibold text-primary">0</div>
    </div>
    <div class="mt-4">
      <div class="d-flex align-items-center justify-content-between gap-3 mb-2">
        <h3 class="h6 mb-0">Colas registradas</h3>
        <button id="refresh" type="button" class="btn btn-sm btn-primary">Actualizar</button>
      </div>
      <div class="list-group small" id="queues">
        <div class="text-muted">Sin colas registradas</div>
      </div>
    </div>
  </div>
</div>`;
    this._onRefresh = this._onRefresh.bind(this);
  }

  connectedCallback() {
    const refreshButton = this.shadowRoot.getElementById('refresh');
    refreshButton.addEventListener('click', this._onRefresh);
    this._fetchMetrics();
    this._fetchQueues();
    this._interval = setInterval(() => {
      this._fetchMetrics();
      this._fetchQueues();
    }, 5000);
  }

  disconnectedCallback() {
    const refreshButton = this.shadowRoot.getElementById('refresh');
    refreshButton.removeEventListener('click', this._onRefresh);
    if (this._interval) {
      clearInterval(this._interval);
    }
  }

  _onRefresh() {
    this._fetchMetrics();
    this._fetchQueues();
  }

  async _fetchMetrics() {
    const endpoint = this.getAttribute('metrics-url') || '/metrics';
    try {
      const response = await fetch(endpoint);
      if (!response.ok) {
        throw new Error('Metrics request failed');
      }
      const data = await response.json();
      this.shadowRoot.getElementById('count').textContent = data.processedCount ?? '0';
    } catch (error) {
      this.shadowRoot.getElementById('count').textContent = 'Error';
      console.error('[queue-monitor]', error);
    }
  }

  async _fetchQueues() {
    const endpoint = this.getAttribute('queues-url') || '/queues';
    try {
      const response = await fetch(endpoint);
      if (!response.ok) {
        throw new Error('Queues request failed');
      }
      const data = await response.json();
      const queues = Array.isArray(data.queues) ? data.queues : [];
      this._renderQueues(queues);
    } catch (error) {
      this._renderQueues(null, error);
      console.error('[queue-monitor]', error);
    }
  }

  _renderQueues(queues, error) {
    const container = this.shadowRoot.getElementById('queues');
    if (!container) {
      return;
    }
    container.innerHTML = '';
    if (error) {
      container.innerHTML = '<div class="alert alert-danger mb-0">Error al cargar colas</div>';
      return;
    }
    if (!queues || queues.length === 0) {
      container.innerHTML = '<div class="text-muted">Sin colas registradas</div>';
      return;
    }
    queues.forEach((queue) => {
      const wrapper = document.createElement('div');
      wrapper.className = 'list-group-item list-group-item-action flex-column gap-2';

      const header = document.createElement('div');
      header.className = 'd-flex justify-content-between align-items-center gap-2';

      const name = document.createElement('span');
      name.className = 'fw-semibold';
      name.textContent = queue.name || '(sin nombre)';

      const badge = document.createElement('span');
      badge.className = 'badge text-bg-primary';
      const total = typeof queue.totalMessages === 'number' ? queue.totalMessages : Array.isArray(queue.messages) ? queue.messages.length : 0;
      badge.textContent = String(total) + ' mensajes';

      header.appendChild(name);
      header.appendChild(badge);
      wrapper.appendChild(header);

      if (Array.isArray(queue.messages) && queue.messages.length > 0) {
        const latestEntry = queue.messages[queue.messages.length - 1];
        const receivedAt = latestEntry.receivedAt
          ? new Date(latestEntry.receivedAt).toLocaleString()
          : 'Sin fecha';
        const payload =
          typeof latestEntry.message === 'object'
            ? JSON.stringify(latestEntry.message)
            : String(latestEntry.message);
        const message = document.createElement('div');
        message.className = 'mt-2 text-muted';
        const label = document.createElement('span');
        label.className = 'd-block small';
        label.textContent = `Ãšltimo mensaje (${receivedAt})`;
        const codeBlock = document.createElement('code');
        codeBlock.className = 'small text-wrap d-block';
        codeBlock.textContent = payload;
        message.append(label, codeBlock);
        wrapper.appendChild(message);
      } else {
        const empty = document.createElement('div');
        empty.className = 'mt-2 text-muted fst-italic';
        empty.textContent = 'Sin mensajes registrados';
        wrapper.appendChild(empty);
      }

      container.appendChild(wrapper);
    });
  }
}

customElements.define('queue-monitor', QueueMonitor);
